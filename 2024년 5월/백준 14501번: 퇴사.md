## 문제
상담원으로 일하고 있는 백준이는 퇴사를 하려고 한다<br>

오늘부터 N+1일째 되는 날 퇴사를 하기 위해서, 남은 N일 동안 최대한 많은 상담을 하려고 한다.<br>

백준이는 비서에게 최대한 많은 상담을 잡으라고 부탁을 했고, 비서는 하루에 하나씩 서로 다른 사람의 상담을 잡아놓았다.<br>

각각의 상담은 상담을 완료하는데 걸리는 기간 Ti와 상담을 했을 때 받을 수 있는 금액 Pi로 이루어져 있다.<br>

N = 7인 경우에 다음과 같은 상담 일정표를 보자.<br>

| 	| 1일 |	2일 |	3일 |	4일 |	5일 |	6일 |	7일 |
|---|-----|-----|-----|-----|-----|-----|-----|  
| Ti |	3 |	5 |	1 |	1 |	2 |	4 |	2 | 
| Pi |	10 |	20 |	10 |	20 |	15 |	40 |	200 |
<br>
1일에 잡혀있는 상담은 총 3일이 걸리며, 상담했을 때 받을 수 있는 금액은 10이다. 5일에 잡혀있는 상담은 총 2일이 걸리며, 받을 수 있는 금액은 15이다.<br>

상담을 하는데 필요한 기간은 1일보다 클 수 있기 때문에, 모든 상담을 할 수는 없다. 예를 들어서 1일에 상담을 하게 되면, 2일, 3일에 있는 상담은 할 수 없게 된다. 2일에 있는 상담을 하게 되면, 3, 4, 5, 6일에 잡혀있는 상담은 할 수 없다.
<br>
또한, N+1일째에는 회사에 없기 때문에, 6, 7일에 있는 상담을 할 수 없다.<br>

퇴사 전에 할 수 있는 상담의 최대 이익은 1일, 4일, 5일에 있는 상담을 하는 것이며, 이때의 이익은 10+20+15=45이다.<br>

상담을 적절히 했을 때, 백준이가 얻을 수 있는 최대 수익을 구하는 프로그램을 작성하시오.<br>

## 입력
첫째 줄에 N (1 ≤ N ≤ 15)이 주어진다.

둘째 줄부터 N개의 줄에 Ti와 Pi가 공백으로 구분되어서 주어지며, 1일부터 N일까지 순서대로 주어진다. (1 ≤ Ti ≤ 5, 1 ≤ Pi ≤ 1,000)

## 출력
첫째 줄에 백준이가 얻을 수 있는 최대 이익을 출력한다.

## 예제 입력 1 
7 <br>
3 10<br>
5 20<br>
1 10<br>
1 20<br>
2 15<br>
4 40<br>
2 200<br>
## 예제 출력 1 
45
## 풀이 과정
현재 날에 상담을 하는 경우와 하지 않는 경우를 비교해서 둘 중 큰 값을 저장하면 된다.<br>
따라서 마지막 날부터 역으로 보면서 계산해보면 된다.<br>
먼저 예제 입력을 보면, <br>
7일째 : 잔여일 1일, 상담일 2일 => 상담 불가<br>
6일째 : 잔여일 2일, 상담일 4일 => 상담 불가<br>
5일째 : 잔여일 3일, 상담일 2일 => 상담 가능<br>
4일째 : 잔여일 4일, 상담일 1일 => 상담 가능<br>
3일째 : 잔여일 5일, 상담일 1일 => 상담 가능<br>
2일째 : 잔여일 6일, 상담일 5일 => 상담 가능<br>
1일째 : 잔여일 7일, 상담일 3일 => 상담 가능<br>
<br>
이렇게 정리할 수 있다.
이 때, 상담이 가능한 날짜들은 반드시 상담을 해야 하는 게 아니라, 현재 날의 상담이 완전히 끝나는 날 이후의 최대 이익과 다음 날의 최대 이익을 비교해준다<br>
그러니까 위 예제에서는 2일 째의 상담을 해서 20의 이익을 얻거나 2일 째의 상담을 하지 않고 3, 4, 5일 째의 이익을 얻을 수 있는 것이다<br>

``` C++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

/*
- 현재 날에 상담을 하는 경우와 하지 않는 경우를 비교
- 상담을 하는 경우 -> 해당 상담이 끝나는 날 이후의 최대 이익을 더함
- 상담을 하지 않는 경우 -> 다음 날의 최대 이익을 그대로 가져옴
- 이 두 경우 중 더 큰 값을 dp[i]에 저장
- 상담이 기간 내에 완료되지 않는 경우도 처리해야 함

*/

int dp[16] = { 0 }; //dp[i] : i번째 날부터 마지막 날까지 얻을 수 있는 최대 이익
vector<pair<int, int>> schedule(16);

int main() {

	int n;
	cin >> n;
	
	for (int i = 0; i < n; i++)
		cin >> schedule[i].first >> schedule[i].second;
	
	for (int i = n - 1; i >= 0; i--) {
		int time = schedule[i].first;
		if (time + i <= n) { //상담 가능
			dp[i] = max(dp[i + 1], dp[time + i] + schedule[i].second);
		}
		else { //상담 불가능
			dp[i] = dp[i + 1];
		}
	}

	cout << dp[0];

	return 0;
}
```
