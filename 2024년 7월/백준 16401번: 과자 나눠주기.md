## 문제
명절이 되면, 홍익이 집에는 조카들이 놀러 온다. 떼를 쓰는 조카들을 달래기 위해 홍익이는 막대 과자를 하나씩 나눠준다.

조카들이 과자를 먹는 동안은 떼를 쓰지 않기 때문에, 홍익이는 조카들에게 최대한 긴 과자를 나눠주려고 한다.

그런데 나눠준 과자의 길이가 하나라도 다르면 조카끼리 싸움이 일어난다. 따라서 반드시 모든 조카에게 같은 길이의 막대 과자를 나눠주어야 한다.

M명의 조카가 있고 N개의 과자가 있을 때, 조카 1명에게 줄 수 있는 막대 과자의 최대 길이를 구하라.

단, 막대 과자는 길이와 상관없이 여러 조각으로 나눠질 수 있지만, 과자를 하나로 합칠 수는 없다. 단, 막대 과자의 길이는 양의 정수여야 한다.

## 입력
첫째 줄에 조카의 수 M (1 ≤ M ≤ 1,000,000), 과자의 수 N (1 ≤ N ≤ 1,000,000)이 주어진다.

둘째 줄에 과자 N개의 길이 L1, L2, ..., LN이 공백으로 구분되어 주어진다. 과자의 길이는 (1 ≤ L1, L2, ..., LN ≤ 1,000,000,000) 를 만족한다.

## 출력
첫째 줄에 조카 1명에게 줄 수 있는 막대 과자의 최대 길이를 출력한다.

단, 모든 조카에게 같은 길이의 막대과자를 나눠줄 수 없다면, 0을 출력한다.

## 예제 입력 1 
```
3 10
1 2 3 4 5 6 7 8 9 10
```
## 예제 출력 1 
```
8
```
## 예제 입력 2 
```
4 3
10 10 15
```
## 예제 출력 2 
```
7
```


## 풀이 과정
과자를 나눠주는 최대 길이를 찾는 문제로, 입력 받은 과자 길이들을 이진 탐색해서 최적의 길이를 구한다<br>
이 때 최소로 나눠줄 수 있는 과자 길이가 1이기 때문에 입력 받은 길이 중 최대 길이를 저장했다가, 이 최대 길이와 최소 길이를 사용해서 이진 탐색을 수행하면 된다<br>

예를 들어 예제 2번에서 조카 4명에게 3개의 과자를 쪼개서라도 나눠줄 수 있다면, 그 때의 최대 길이를 구해야 한다<br>
따라서 맨 처음은 다음과 같이 시작하게 된다
```
최소 길이 = 1
최대 길이 = 15
검사할 길이 = (1+15)/2 = 8
```
길이 8로 나눠줄 수 있는지 검사해보면 다음과 같다
```
10은 8을 1번 포함함
10은 8을 1번 포함함
15는 8을 1번 포함함
```
즉 같은 길이로 3명에게만 분배 가능하므로 다시 검사를 수행한다. 다음과 같이 설정해서 진행한다
```
1) '조카 수 > 포함 개수' 이면 '최대 길이 = 검사할 길이 - 1'
2) '조카 수 < 포함 개수' 이면 '최소 길이 = 검사할 길이 + 1'
```


그럼 이 경우 두 번째에 해당되기 때문에 최대 길이가 7이 된다
```
최소 길이 = 1
최대 길이 = 7
검사할 길이 = (1+7)/2 = 4
```
길이 4로 나눠줄 수 있는지 검사해보면 다음과 같다
```
10은 4를 2번 포함함
10은 4를 2번 포함함
15는 4를 3번 포함함
```

이 경우는 조카 수 보다 포함 개수가 많은 경우이고, 더 긴 길이도 가능한지 확인해야 하므로 최소 길이가 5가 된다
```
최소 길이 = 5
최대 길이 = 7
검사할 길이 = (5+7)/2 = 6
```
길이 6으로 나눠줄 수 있는지 검사해보면 다음과 같다
```
10은 6을 1번 포함함
10은 6을 1번 포함함
15는 6을 2번 포함함
```

조카 수와 포함 개수가 일치한다. 그러나 더 긴 길이도 가능한지 확인해야 하므로 최소 길이는 6이 된다
```
최소 길이 = 6
최대 길이 = 7
검사할 길이 = (6+7)/2 = 7
```
길이 7로 나눠줄 수 있는지 검사해보면 다음과 같다
```
10은 7을 1번 포함함
10은 7을 1번 포함함
15는 7을 2번 포함함
```
조카 수와 포함 개수가 일치한다. 그러나 더 긴 길이도 가능하지 확인해야 하므로 최소 길이는 7이 된다
그러나 이 경우 최소 길이와 최대 길이가 일치하게 되고, 이미 최대 길이 아래에서 가능한 최대 길이가 계산되었기 때문에 최종 결과는 7이 된다

```C++
#include <iostream>
#include <vector>
#include <algorithm>

#define fastio ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)

using namespace std;

vector<long> cookies;

int main() {

	fastio;

	long m, n, answer = 0; 
	long  maxLen = 0, minLen = 1;
	cin >> m >> n;
	cookies.resize(n);

	for (int i = 0; i < n; i++) {
		cin >> cookies[i];
		maxLen = max(maxLen, cookies[i]);
	}

	while (true) {

		if (minLen > maxLen) break;

		long mid = (minLen + maxLen) / 2;
		int cnt = 0;

		for (auto cookie : cookies) {
			int c = cookie / mid;
			while (c--) cnt++;
		}
		if (cnt >= m) { 
			minLen = mid + 1;
			answer = max(answer, mid);
		}
		else if (cnt < m) maxLen = mid - 1;
	}

	cout << answer;

	return 0;
}
```



