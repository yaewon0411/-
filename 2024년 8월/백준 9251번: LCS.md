## 문제
LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다.

예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다.

## 입력
첫째 줄과 둘째 줄에 두 문자열이 주어진다. 문자열은 알파벳 대문자로만 이루어져 있으며, 최대 1000글자로 이루어져 있다.

## 출력
첫째 줄에 입력으로 주어진 두 문자열의 LCS의 길이를 출력한다.

## 예제 입력 1 
```
ACAYKP
CAPCAK
```
## 예제 출력 1 
```
4
```

## 풀이

공통의 부분 수열이 되는 경우를 확인해야 한다<br>
예제를 사용해서 규칙을 확인했다

먼저 ACAYKP의 첫 번째 문자 'A'에 대해서 CAPCAK를 검사한다<br>
이 때 검사하는 문자열의 부분 문자열에 대해서 확인하는 문자를 부분 수열로 갖는 경우가 있는지를 확인한다<br>
A에 대해 가능한 부분 수열은 {}, {A} 이 둘 중 하나이다
```text
C : C -> {}             
A : CA -> {A} 가능      
P : CAP -> {A} 가능
C : CAPC -> {A} 가능
A : CAPCA -> {A} 가능
K : CAPCAK -> {A} 가능
```
두 번째 문자 'C'에 대해서 CAPCAK를 검사한다<br>
C만을 부분 수열로 갖는 경우가 있는지도 확인해야 하지만 AC를 부분 수열로 갖는 지도 확인해야 한다<br>
AC에 대해 가능한 부분 수열은 {}, {A}, {C}, {A, C} 이 중 하나인데 A에 대해서는 이미 검사했다<br>
'긴 부분 수열'이 가능한지를 확인하는 것이기 때문에 {C}와 {A, C}가 가능한 경우를 확인한다 
```text
C : C -> {C} 가능
A : CA -> {C} 가능
P : CAP -> {C} 가능
C : CAPC -> {A, C} 가능
A : CAPCA -> {A, C} 가능
K : CAPCAK -> {A, C} 가능
```

네 번째 문자 'A'에 대해서 CAPCAK를 검사한다<br>
ACA를 확인한다
```text
C : C -> {C} 가능
A : CA -> {C, A} 가능 
P : CAP -> {A, C} 가능
C : CAPC -> {A, C} 가능
A : CAPCA -> {A, C, A} 가능
K : CAPCAK -> {A, C, A} 가능
```

현재 검사하는 문자와 검사 대상 문자열의 문자가 동일하면 가능한 부분 수열 길이가 1 늘어나고 있다<br>
CAPCA에서 5번째 줄 {A, C, A}는 이전 검사한 부분 수열 AC에 대해서 {A, C}에 A가 추가된 {A, C, A}이다<br>
즉 검사하는 문자가 동일하면 이전 검사 문자를 통해 확인한 최장 부분 수열에 현재 문자를 포함시키는 것이 된다<br>

현재 검사하는 문자와 검사 대상 문자열의 문자가 다르면 이전까지 검사된 부분 수열 중 길이가 긴 경우를 갖게 된다<br>


현재 검사하는 문자의 위치와 검사 대상 문자열의 문자 위치에 대한 부분 수열 길이를 저장하는 것이기 때문에<br>
i를 검사하는 ACAYKP의 인덱스, j를 CAPCAK를 검사하는 인덱스라고 하면<br>
dp[i][j] = 문자 위치 i와 j에서 갖는 긴 부분 수열 길이<br>
이렇게 된다<br>
인덱스가 1부터 시작된다고 가정하면 인덱스가 6일 때의 값인 dp[6][6]이 두 문자열의 끝까지 확인한 경우가 되므로 답이 된다<br>

두 번째 문자 'C'를 검사한 경우를 보면 {C}가 가능하면서 동시에 {A}가 가능한 경우가 있다<br>
AC에 대해서 CA를 검사할 때 CA는 {C}도 가능한데 {A}도 가능했다<br>
그러나 부분 문자열의 길이가 1로 동일하기 때문에 C가 가능하든 A가 가능하든 결과적으로 가능한 길이가 1이 된다<br>
즉 문자 위치 i와 j에서의 문자가 다르다면 바로 직전까지 검사한 j-1까지의 부분수열과 i-1에서 j까지 검사한 부분수열 중 긴 길이를 가지면 되는 것이다<br>

즉 다음과 같이 식을 세울 수 있다<br>
```text
두 문자열 A, B에 대해서
if (A[i]==B[j]) :
  dp[i][j] = dp[i-1][j-1] + 1
else :
  dp[i][j] = max(dp[i-1][j], dp[i][j-1])

```

```C++
#include <iostream>
#include <vector>

using namespace std;

int dp[1001][1001];

int main() {

	for (int i = 0; i < 1001; i++) {
		dp[i][0] = 0;
		dp[0][i] = 0;
	}

	string a, b;
	cin >> a >> b;

	for (int i = 0; i < a.length(); i++) {
		for (int j = 0; j < b.length(); j++) {
			if (a[i] == b[j]) {
				dp[i+1][j+1] = dp[i+1][j] + 1;
			}
			else {
				dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j]);
			}
		}
	}
	
	cout << dp[a.length()][b.length()];

	return 0;
}
```










