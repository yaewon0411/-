https://school.programmers.co.kr/learn/courses/30/lessons/42627

## 문제
하드디스크는 한 번에 하나의 작업만 수행할 수 있습니다. 디스크 컨트롤러를 구현하는 방법은 여러 가지가 있습니다. 가장 일반적인 방법은 요청이 들어온 순서대로 처리하는 것입니다.

예를들어
```
- 0ms 시점에 3ms가 소요되는 A작업 요청
- 1ms 시점에 9ms가 소요되는 B작업 요청
- 2ms 시점에 6ms가 소요되는 C작업 요청
```
한 번에 하나의 요청만을 수행할 수 있기 때문에 각각의 작업을 요청받은 순서대로 처리하면 다음과 같이 처리 됩니다.
```
- A: 3ms 시점에 작업 완료 (요청에서 종료까지 : 3ms)
- B: 1ms부터 대기하다가, 3ms 시점에 작업을 시작해서 12ms 시점에 작업 완료(요청에서 종료까지 : 11ms)
- C: 2ms부터 대기하다가, 12ms 시점에 작업을 시작해서 18ms 시점에 작업 완료(요청에서 종료까지 : 16ms)
```
이 때 각 작업의 요청부터 종료까지 걸린 시간의 평균은 10ms(= (3 + 11 + 16) / 3)가 됩니다.
<br>
하지만 A → C → B 순서대로 처리하면
```
- A: 3ms 시점에 작업 완료(요청에서 종료까지 : 3ms)
- C: 2ms부터 대기하다가, 3ms 시점에 작업을 시작해서 9ms 시점에 작업 완료(요청에서 종료까지 : 7ms)
- B: 1ms부터 대기하다가, 9ms 시점에 작업을 시작해서 18ms 시점에 작업 완료(요청에서 종료까지 : 17ms)
```
이렇게 A → C → B의 순서로 처리하면 각 작업의 요청부터 종료까지 걸린 시간의 평균은 9ms(= (3 + 7 + 17) / 3)가 됩니다.
<br>
각 작업에 대해 [작업이 요청되는 시점, 작업의 소요시간]을 담은 2차원 배열 jobs가 매개변수로 주어질 때, 작업의 요청부터 종료까지 걸린 시간의 평균을 가장 줄이는 방법으로 처리하면 평균이 얼마가 되는지 return 하도록 solution 함수를 작성해주세요. (단, 소수점 이하의 수는 버립니다)

## 제한 사항
jobs의 길이는 1 이상 500 이하입니다. <br>
jobs의 각 행은 하나의 작업에 대한 [작업이 요청되는 시점, 작업의 소요시간] 입니다.<br>
각 작업에 대해 작업이 요청되는 시간은 0 이상 1,000 이하입니다.<br>
각 작업에 대해 작업의 소요시간은 1 이상 1,000 이하입니다.<br>
하드디스크가 작업을 수행하고 있지 않을 때에는 먼저 요청이 들어온 작업부터 처리합니다.<br>


## 풀이

처음엔 작업 요청 시점이 가장 작은 작업을 꺼내서 요청에서 종료시점까지의 시간을 구한 후,
jobs를 소요 시간이 적은 순으로 정렬해서 순차적으로 처리해서 값을 누적하는 식으로 처리했다<<br>

그런데 이렇게 되면 다음 작업을 처리할 때, 소요 시간만 고려하게 되고 요청이 들어온 시점이 고려되지 않아서 특정 작업의 대기 시간이 계속 증가하게 되는 경우가 발생한다<br>
예를 들어 jobs = { {1, 4} ,{7, 9},{1000, 3} } 라고 가정하면, 작업 소요 시간만을 고려했을 때 다음과 같이 된다
```
4ms 시점에 작업 완료(요청에서 종료까지 : 4ms)
1000ms부터 대기하다가, 1000ms 시점에 작업을 시작해서 1003ms 시점에 작업 완료(요청에서 종료까지 : 3ms)
7ms부터 대기하다가, 1003ms 시점에 작업을 시작해서 1012ms 시점에 작업 완료(요청에서 종료까지 : 1005ms)

(4+3+1005)/3 = 337
```
따라서 현재 시점에서 다음 처리 가능한 작업의 요청 시점을 같이 고려해야 대기 시간이 무한히 증가하는 경우를 막을 수 있다
```
4ms 시점에 작업 완료(요청에서 종료까지 : 4ms)
7ms부터 대기하다가, 7ms 시점에 작업을 시작해서 16ms 시점에 작업 완료(요청에서 종료까지 : 9ms)
1000ms부터 대기하다가, 1000ms 시점에 작업을 시작해서 1003ms 시점에 작업 완료(요청에서 종료까지 : 3ms)

(4+9+3)/3 = 5
```

즉 다음과 같다
```
1. 현재 시점에서 처리 가능한 작업들을 소요 시간 최소우선순위 큐에 넣는다
2. 큐가 빌 때까지 총 작업 소요 시간을 구한다
3. 큐가 비면 현재 시점에서 처리 가능한 작업들을 소요시간 최소우선순위에 따라 다 처리했다는 것
4. 따라서 현재 시점을 다음 작업의 요청 시점으로 옮겨서 다시 반복
5. 모든 작업 개수만큼 반복을 끝내면 '총작업소요시간/작업개수'를 반환
```

<br>
<br>

```C++

#include <vector>
#include <algorithm>
#include <queue>
using namespace std;

int solution(vector<vector<int>> jobs) {

    sort(jobs.begin(), jobs.end()); //요청 시간 기준으로 정렬

    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;

    int currentTime = 0;
    int totalWaitTime = 0;
    int index = 0, cnt = 0, n = jobs.size();

    while (cnt < n) {
        //jobs[0][0] : 요청시간, jobs[0][1] = 소요시간

        //현재 시간에서 처리 가능한 작업들을 큐에 삽입
        while (index < n && jobs[index][0] <= currentTime) {
            pq.push({ jobs[index][1], jobs[index][0] }); //(duration, requestTime)
            index++;
        }

        if (!pq.empty()) {
            //가장 소요 시간이 짧은 작업 꺼내기
            int duration = pq.top().first;
            int requestTime = pq.top().second;

            pq.pop();

            currentTime += duration;
            totalWaitTime += currentTime - requestTime;
            cnt++;
        }
        else {
            //큐가 비어있다면, 다음 작업의 요청 시간으로 현재 시간을 갱신
            currentTime = jobs[index][0];
        }
    }
    return totalWaitTime / n;
}
```






