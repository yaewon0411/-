## 문제
수열 S가 어떤 수 Sk를 기준으로 S1 < S2 < ... Sk-1 < Sk > Sk+1 > ... SN-1 > SN을 만족한다면, 그 수열을 바이토닉 수열이라고 한다.

예를 들어, {10, 20, 30, 25, 20}과 {10, 20, 30, 40}, {50, 40, 25, 10} 은 바이토닉 수열이지만, {1, 2, 3, 2, 1, 2, 3, 2, 1}과 {10, 20, 30, 40, 20, 30} 은 바이토닉 수열이 아니다.

수열 A가 주어졌을 때, 그 수열의 부분 수열 중 바이토닉 수열이면서 가장 긴 수열의 길이를 구하는 프로그램을 작성하시오.

## 입력
첫째 줄에 수열 A의 크기 N이 주어지고, 둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ N ≤ 1,000, 1 ≤ Ai ≤ 1,000)

## 출력
첫째 줄에 수열 A의 부분 수열 중에서 가장 긴 바이토닉 수열의 길이를 출력한다.

## 예제 입력 1 
```
10
1 5 2 1 4 3 4 5 2 1
```
## 예제 출력 1 
```
7
```

## 풀이

증가하다가 Sk 지점 이후부터는 감소하는 수열을 찾아야 하는데, 입력으로 받은 수열 중 최대값을 기준(SK)으로해서 검사한다 해도 항상 그 최대값을 포함하는 경우가 긴 수열의 길이임이 보장되지 않는다<br>
따라서 왼쪽에서 오른쪽으로 검사하면서 가장 길게 증가하는 부분 수열 길이를 카운트하고, 오른쪽에서 왼쪽으로 검사하면서 가장 길게 증가하는 부분 수열 길이를 카운트 한 후에 각 인덱스 별로 두 카운트 값을 더한 후 1을 빼주는 식으로 구했다.<br>
1을 빼는 이유는 해당 위치의 수가 두 번 검사되는 것이기 때문이다<br>

따라서 두 개의 DP 배열 dpL과 dpR을 사용했다<br>
두 배열의 초기값은 1로 설정해서, 자신보다 큰 숫자를 발견하지 못했을 경우 그대로 길이 1을 갖게 했다<br>
1 5 2 1 을 보면 1이 그 어느 수보다 크지 못하지만 1 자체가 부분 수열로 길이 1이 되기 때문이다<br>

예제에 적용하면 다음과 같이 된다
```text
      1 5 2 1 4 3 4 5 2 1
dpL : 1 2 2 1 3 3 4 5 2 1
dpR : 1 5 2 1 4 3 3 3 2 1
합  : 2 7 4 2 7 6 7 8 4 2
```
합이 8인 경우를 보면 왼쪽에서 5까지 증가된 부분 수열 길이가 자기 자신을 포함해 5인 것을 알 수 있고(1, 2, 3, 4, 5) <br>
오른쪽에서 해당 5까지 증가된 부분 수열 길이가 자기 자신을 포함해 3인 것을 알 수 있다(5, 2, 1)<br>
5가 두 번 사용됐으니 8 - 1 = 7인 7이 답이 된다


```C++
#include <iostream>
#include <vector>

using namespace std;


int main() {

	int n, answer = 0;
	cin >> n;
	vector<int> v(n+1, 0), dpL(n+1, 1), dpR(n+1, 1);

	for (int i = 1; i <= n; i++) {
		cin >> v[i];
		for (int j = i - 1; j >= 1; j--) {
			if (v[i] > v[j]) {
				dpL[i] = max(dpL[i], dpL[j] + 1);
			}
		}
	}


	for (int i = n-1; i >= 1; i--) {
		for (int j = i+1; j <=n; j++) {
			if (v[i] > v[j]) {
				dpR[i] = max(dpR[i], dpR[j] + 1);
			}
		}
	}


	for (int i = 1; i <= n; i++) {
		answer = max(answer, dpL[i] + dpR[i]-1);
	}
	cout << answer;
	

	return 0;
}

```
