## 문제
수열 S가 어떤 수 Sk를 기준으로 S1 < S2 < ... Sk-1 < Sk > Sk+1 > ... SN-1 > SN을 만족한다면, 그 수열을 바이토닉 수열이라고 한다.

예를 들어, {10, 20, 30, 25, 20}과 {10, 20, 30, 40}, {50, 40, 25, 10} 은 바이토닉 수열이지만,  {1, 2, 3, 2, 1, 2, 3, 2, 1}과 {10, 20, 30, 40, 20, 30} 은 바이토닉 수열이 아니다.

수열 A가 주어졌을 때, 그 수열의 부분 수열 중 바이토닉 수열이면서 가장 긴 수열의 길이를 구하는 프로그램을 작성하시오.

## 입력
첫째 줄에 수열 A의 크기 N이 주어지고, 둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ N ≤ 1,000, 1 ≤ Ai ≤ 1,000)

## 출력
첫째 줄에 수열 A의 부분 수열 중에서 가장 긴 바이토닉 수열의 길이를 출력한다.

예제 입력 1 
10
1 5 2 1 4 3 4 5 2 1<br>
예제 출력 1 
7

## 풀이 과정
어떤 수를 기준으로, 그 수를 만나기 이전까지는 계속 증가했다가, 이후로는 계속 감소하는 길이의 최대값을 구해야 한다.

처음에는 왼쪽에서부터 증가하는 가장 긴 바이토닉 수열의 길이와, 그 위치의 인덱스를 저장했다가

그 인덱스를 기준으로 작아지는 부분 수열의 길이를 구하여 더하는 방식으로 생각했다.

그런데 1 4 3 2 5 1 인 경우에서 위 방식으로 검사하면, 왼쪽에서 증가하는 부분 수열의 최대 길이는 3이되고 이 때의 인덱스는 5의 위치를 저장한다. 
그리고 5에서부터 우측으로 감소하는 부분 수열의 길이를 구하면 2가 된다. 즉 3+2-1 = 4가 된다 (이 때, 5는 두 번 더해지므로 한 번 차감).
그러나 실제로 위 경우의 최대값은 5이다. ( [1,4] (길이2) + [4,3,2,1] (길이4) - 1 = 5)

따라서 다음의 방식으로 설계했다<br>
1) 왼쪽에서부터 증가하는 가장 긴 바이토닉 수열의 길이를 l_dp[]에 저장한다
2) 오른쪽에서부터 증가하는 가장 긴 바이토닉 수열의 길이를 r_dp[]에 저장한다
3) 두 배열에서 같은 인덱스를 갖는 원소의 값을 더한 것 중 '최대값 - 1'을 출력한다

왼쪽에서부터 증가하는 가장 긴 부분 수열의 길이를 구하기 위해서는 기준 수 K에서 왼쪽으로 K보다 작은 수가 있는 지 확인하고, 

마지막으로 확인한 수가 갖는 (그 수를 기준으로 검사했을 때 저장한)길이에 +1을 해서 배열에 저장하면 된다.

이에 대한 조건문은 다음과 같다.

```
//배열의 길이는 N
for (int i = 0; i < n; i++) {
  int tmp = 0;
  for (int j = 0; j < i; j++) {
    if (ary[i] > ary[j] && l_dp[j] > tmp) {
      tmp = l_dp[j];
    }
  }
  l_dp[i] = tmp + 1;
}
```
예제의 경우를 적용해보자
1 5 2 1 4 3 4 5 2 1<br>

1. i=0 //ary[0] = 1
(1) j=0 : (1>1 && 0>0) 조건에 충족하지 못하므로 l_dp[0] = 1
2.  





```
#include <iostream>
using namespace std;

int ary[1001];
int *l_dp; //왼쪽에서부터 검사하며 길이 저장
int *r_dp; //오른쪽에서부터 검사하며 길이 저장

int main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	int n, left_max = 0, ans = 0;
	cin >> n;
	l_dp = new int[n+1];
	r_dp = new int[n+1];

	for (int i = 0; i < n; i++)
		cin >> ary[i];

	for (int i = 0; i < n; i++) {
		int tmp = 0;
		for (int j = 0; j < i; j++) {
			if (ary[i] > ary[j] && l_dp[j] > tmp) {
				tmp = l_dp[j];
			}
		}
		l_dp[i] = tmp + 1;
	}

	for (int i = n-1; i >= 0; i--) {
		int tmp = 0;
		for (int j = n-1; j > i; j--) {
			if (ary[i]>ary[j] && r_dp[j]> tmp) {
				tmp = r_dp[j];
			}
		}
		r_dp[i] = tmp + 1;
	}

	for (int i = 0; i < n; i++) {
		if (ans < l_dp[i] + r_dp[i] - 1 ) {
			ans = l_dp[i] + r_dp[i] - 1;
		}
	}
	cout << ans;
}
```
