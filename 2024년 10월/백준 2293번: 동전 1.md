## 문제
n가지 종류의 동전이 있다. 각각의 동전이 나타내는 가치는 다르다. 이 동전을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다. 그 경우의 수를 구하시오. 각각의 동전은 몇 개라도 사용할 수 있다.

사용한 동전의 구성이 같은데, 순서만 다른 것은 같은 경우이다.

## 입력
첫째 줄에 n, k가 주어진다. (1 ≤ n ≤ 100, 1 ≤ k ≤ 10,000) 다음 n개의 줄에는 각각의 동전의 가치가 주어진다. 동전의 가치는 100,000보다 작거나 같은 자연수이다.

## 출력
첫째 줄에 경우의 수를 출력한다. 경우의 수는 231보다 작다.

## 예제 입력 1 
```
3 10
1
2
5
```
## 예제 출력 1 
```
10
```

## 풀이

처음에 DFS로 풀었다가 바로 메모리 초과에 걸려서 dp를 사용했다

각 동전에 대해 동전이 사용되는 경우를 생각해보면 다음과 같다. 예제를 사용하고 k를 5로 변경했다<br>
dp[i]는 금액 i원을 만들 수 있는 경우의 수 이다
```
dp[0] = 1 (동전이 사용되지 않음)
dp[1] = {1} = 1
dp[2] = {1, 1} + {2} = 2
dp[3] = {1, 1, 1} + {2, 1} = 2
dp[4] = {1, 1, 1, 1} + {2, 1, 1} + {2, 2} = 3
dp[5] = {1, 1, 1, 1, 1} + {2, 1, 1, 1} + {2, 2, 1} + {5} = 4
```
먼저 동전 1원은 모든 경우에서 사용 가능하기 때문에 각 금액에서 1원이 추가된 것을 볼 수 있다<br>
그 다음 동전 2원의 경우를 보는데, dp[2]에서 볼 수 있듯이 이미 1원을 사용한 경우의 수에 더해지게 된다<br>
그러니까 1원으로만 만든 금액에 2원을 더한 경우나, 2원만으로 만든 경우를 합쳐서 경우의 수가 갱신된다<br>

이를 다시 보면
```
dp[1] = dp[1] + dp[0] -> 0원에서 출발해 1원을 추가한 경우
dp[2] = dp[2] + dp[1] -> 1원에서 출발해 1원을 추가한 경우
...
dp[5] = dp[5] + dp[4] -> 4원에서 출발해 1원을 추가하 경우

이렇게 1원이 사용 가능한 경우에 대해 금액 별로 1원을 더하는 방식으로 갱신이 일어나고

2원이 사용 가능한 경우에 대해서는 기존에 1원으로 만든 금액에 2원이 추가되거나
2원만으로 새로운 금액이 만들어진다

dp[2] = dp[2] + dp[0] -> 기존에 1원을 더한 경우 + 0원에서 출발해 2원을 추가하는 경우
dp[3] = dp[3] + dp[1] -> 기존에 1원을 더한 경우 + 1원을 만든 경우에 2원을 추가하는 경우
dp[4] = dp[4] + dp[2] -> 기존에 1원을 더한 경우 + 2원을 만든 경우에 2원을 추가하는 경우
....
이렇게 된다

```
그래서 dp[i] = dp[i] + dp[i-현재금액] 이렇게 누적이 이루어진다

```C++
#include <iostream>
#include <vector>

#define fastio cin.tie(0), cout.tie(0), ios::sync_with_stdio(0)

using namespace std;


int k, n;

int main() {

	fastio;
	cin >> n >> k;

	vector<int> coin(n, 0);
	vector<int> dp(k + 1, 0);

	for (int i = 0; i < n; i++) cin >> coin[i];

	dp[0] = 1;

	for (auto c : coin) {
		for (int i = c; i <= k; i++) {
			dp[i] = dp[i] + dp[i - c];
		}
	}

	cout << dp[k];

	return 0;
}
```


