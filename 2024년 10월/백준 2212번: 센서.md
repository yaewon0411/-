## 문제
한국도로공사는 고속도로의 유비쿼터스화를 위해 고속도로 위에 N개의 센서를 설치하였다. 문제는 이 센서들이 수집한 자료들을 모으고 분석할 몇 개의 집중국을 세우는 일인데, 예산상의 문제로, 고속도로 위에 최대 K개의 집중국을 세울 수 있다고 한다.

각 집중국은 센서의 수신 가능 영역을 조절할 수 있다. 집중국의 수신 가능 영역은 고속도로 상에서 연결된 구간으로 나타나게 된다. N개의 센서가 적어도 하나의 집중국과는 통신이 가능해야 하며, 집중국의 유지비 문제로 인해 각 집중국의 수신 가능 영역의 길이의 합을 최소화해야 한다.

편의를 위해 고속도로는 평면상의 직선이라고 가정하고, 센서들은 이 직선 위의 한 기점인 원점으로부터의 정수 거리의 위치에 놓여 있다고 하자. 따라서, 각 센서의 좌표는 정수 하나로 표현된다. 이 상황에서 각 집중국의 수신 가능영역의 거리의 합의 최솟값을 구하는 프로그램을 작성하시오. 단, 집중국의 수신 가능영역의 길이는 0 이상이며 모든 센서의 좌표가 다를 필요는 없다.

## 입력
첫째 줄에 센서의 개수 N(1 ≤ N ≤ 10,000), 둘째 줄에 집중국의 개수 K(1 ≤ K ≤ 1000)가 주어진다. 셋째 줄에는 N개의 센서의 좌표가 한 개의 정수로 N개 주어진다. 각 좌표 사이에는 빈 칸이 하나 있으며, 좌표의 절댓값은 1,000,000 이하이다.

## 출력
첫째 줄에 문제에서 설명한 최대 K개의 집중국의 수신 가능 영역의 길이의 합의 최솟값을 출력한다.

## 예제 입력 1 
```
6
2
1 6 9 3 6 7
```
## 예제 출력 1 
```
5
```

## 풀이
센서가 멀리 떨어져 있을 수록 집중국의 수신 범위가 넓어지므로 센서 간 거리를 계산해서 그룹으로 묶어야 한다<br>
좌표가 무작위로 주어지기 때문에 중복을 제거하고 오름차순으로 정렬한 후 인접한 센서들 간의 좌표 차이를 구한다<br>
예시의 경우 센서 좌표는 [1, 3, 6, 7, 9]가 되고 인접한 센서 간의 거리는 [2, 3, 1, 2]가 된다<br>

집중국이 2개이기 때문에 센서를 2개의 그룹으로 나누는데, 이 때 인접한 센서들 간의 거리가 큰 곳을 기준으로 그룹을 나눠야 한다<br>
왜냐하면 센서 간의 거리가 크면 하나의 집중국이 커버해야 할 범위가 넓어지기 때문이다<br>

[2, 3, 1, 2]에서 3을 기준으로 구간을 나누면 (2), (1, 2)로 나눌 수 있고, 이 때 최소 수신 가능 합이 5가 된다

따라서 집중국 개수가 k일 때, 내림차순 정렬한 인접 센서 거리 리스트에서 k-1개를 제외해서 최소 수신 가능 합을 구한다

```C++
#include <iostream>
#include <vector>
#include <algorithm>
#include <set>

#define fastio cin.tie(0), cout.tie(0), ios::sync_with_stdio(0)

using namespace std;


int main() {

	fastio;
	int n, k, sensor, answer=0;
	cin >> n >> k;

	set<int> sensors;

	for (int i = 0; i < n; i++) {
		cin >> sensor;
		sensors.insert(sensor);
	}

	if (k >= sensors.size()) {
		cout << 0;
		return 0;
	}

	vector<int> distances;
	auto it = sensors.begin();
	int prev = *it;
	it++;

	for (; it != sensors.end(); it++) {
		distances.push_back(*it - prev);
		prev = *it;
	}

	sort(distances.begin(), distances.end(), greater<int>());

	for (int i = k - 1; i < distances.size(); i++) {
		answer += distances[i];
	}

	cout << answer;

	return 0;
}

```
