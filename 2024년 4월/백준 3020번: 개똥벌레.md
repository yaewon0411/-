
 
## 시간 제한
1 초	
## 문제
개똥벌레 한 마리가 장애물(석순과 종유석)로 가득찬 동굴에 들어갔다. 동굴의 길이는 N미터이고, 높이는 H미터이다. (N은 짝수) 첫 번째 장애물은 항상 석순이고, 그 다음에는 종유석과 석순이 번갈아가면서 등장한다.

아래 그림은 길이가 14미터이고 높이가 5미터인 동굴이다. (예제 그림)



이 개똥벌레는 장애물을 피하지 않는다. 자신이 지나갈 구간을 정한 다음 일직선으로 지나가면서 만나는 모든 장애물을 파괴한다.

위의 그림에서 4번째 구간으로 개똥벌레가 날아간다면 파괴해야하는 장애물의 수는 총 여덟개이다. (4번째 구간은 길이가 3인 석순과 길이가 4인 석순의 중간지점을 말한다)



하지만, 첫 번째 구간이나 다섯 번째 구간으로 날아간다면 개똥벌레는 장애물 일곱개만 파괴하면 된다.

동굴의 크기와 높이, 모든 장애물의 크기가 주어진다. 이때, 개똥벌레가 파괴해야하는 장애물의 최솟값과 그러한 구간이 총 몇 개 있는지 구하는 프로그램을 작성하시오.

## 입력
첫째 줄에 N과 H가 주어진다. N은 항상 짝수이다. (2 ≤ N ≤ 200,000, 2 ≤ H ≤ 500,000)

다음 N개 줄에는 장애물의 크기가 순서대로 주어진다. 장애물의 크기는 H보다 작은 양수이다.

## 출력
첫째 줄에 개똥벌레가 파괴해야 하는 장애물의 최솟값과 그러한 구간의 수를 공백으로 구분하여 출력한다.

## 예제 입력 1 
6 7<br>
1<br>
5<br>
3<br>
3<br>
5<br>
1<br>
## 예제 출력 1 
2 3

## 풀이 과정
제한 시간이 1초로 걸려있어서 시간 복잡도를 증가시키는 방향으로 짜면 틀린다<br>
처음에 장애물의 높이별로 충돌하는 횟수를 직접적으로 카운트했어서 시간 제한에 걸렸다.<br>
이 문제는 누적 합을 사용해서 한 번의 반복 안에서 충돌 카운트가 이루어지게 해야 통과한다.<br>

예를 들어 석순의 구간 별 충돌 횟수를 세는 배열을 bottom이라고 하자.<br>
입력으로 들어온 석순의 높이가 h라면,<br>
(1) bottom[1]++ <br>
(2) bottom[h+1]-- <br>
을 해준다. h가 어떻든 구간 1에는 무조건 걸리게 되어있고, h+1부터는 석순이 충돌될 수 없기 때문이다.

<br>
종유석 같은 경우는 h만큼 위에서 아래로 내려온다. 종유석의 구간 별 충돌 횟수를 세는 배열을 top이라고 하면,<br>
(1)top[동굴높이-h+1]++ <br>
(2)top[동굴높이+1]-- <br>
을 해준다. 종유석이 위에서 h만큼 내려온 곳부터 시작하고, 종유석은 '동굴높이-h'에서 끝나기 때문이다<br>

```C++

#include <iostream>
#include <vector>

using namespace std;
int main() {

	int n, h, num=0, index=0, len, minValue = INT_MAX, cnt=0;
	cin >> n >> h;

	vector<int> top(h + 1, 0), bottom(h + 1, 0);
	for (int i = 0; i < n; i++) {
		cin >> num;
		if (i % 2 == 0) {
			bottom[1]++;
			bottom[num + 1]--;
		}
		else {
			top[h - num + 1]++;
			top[h+1]--;
		}
	}

	for (int i = 1; i <= h; i++) {
		bottom[i] += bottom[i - 1];
		top[i] += top[i - 1];
	}

	for (int i = 1; i <= h; i++) {
		len = bottom[i] + top[i];
		if (len < minValue) {
			minValue = len;
			cnt = 1;
		}
		else if (len == minValue) cnt++;
	}


	cout << minValue << " " << cnt;

	return 0;
}
```
