## 문제
N×N의 표에 수 N2개 채워져 있다. 채워진 수에는 한 가지 특징이 있는데, 모든 수는 자신의 한 칸 위에 있는 수보다 크다는 것이다. N=5일 때의 예를 보자.

```
12	7	9	15	5
13	8	11	19	6
21	10	26	31	16
48	14	28	35	25
52	20	32	41	49
```
이러한 표가 주어졌을 때, N번째 큰 수를 찾는 프로그램을 작성하시오. 표에 채워진 수는 모두 다르다.

## 입력
첫째 줄에 N(1 ≤ N ≤ 1,500)이 주어진다. 다음 N개의 줄에는 각 줄마다 N개의 수가 주어진다. 표에 적힌 수는 -10억보다 크거나 같고, 10억보다 작거나 같은 정수이다.

## 출력
첫째 줄에 N번째 큰 수를 출력한다.

## 예제 입력 1 
```
5
12 7 9 15 5
13 8 11 19 6
21 10 26 31 16
48 14 28 35 25
52 20 32 41 49
```
## 예제 출력 1 
```
35
```

## 풀이

세 가지 시도를 했는데 먼저 두 가지 방법이 왜 실패했는지를 정리하고 성공한 마지막 풀이를 정리하도록 한다<br>

### 1. set 사용 

set에 정렬 조건을 넣어서 입력으로 들어온 숫자들이 내림차순 정렬되게 했다

메모리 초과가 발생했고 그 이유는 다음과 같다

set은 레드 블랙 트리로 구현되어 있어 각 노드마다 추가 메모리가 필요하다

각 노드당 필요한 메모리는:
  - 값 저장 -> 4byte (int)
  - 좌/우 자식, 부모 포인터 저장 -> 24byte
  - 색상 정보 -> 1byte

로 총 약 30 byte로 노드가 구성되고 문제 조건에 따라 N이 1500일 때 필요한 메모리가 다음과 같아서 메모리 초과가 발생했다:
  - 1500 * 1500 * 30 = 약 67.5mb -> 12mb 제한 초과



### 2. 우선순위 큐 사용

우선순위 큐는 배열 기반 힙으로 구현되어 있어 set보다 효율적이지만 여전히 부족하다

각 원소당 필요한 메모리는:
  - 값 저장 -> 4byte (int)
  - 힙 구조 유지를 위한 오버헤드 -> 약 16byte

로 원소 당 약 20byte가 필요하고 문제 조건에 따라 N이 1500일 때 필요한 메모리가 다음과 같아서 메모리 초과가 발생했다:
  - 1500 * 1500 * 20 = 약 21.5mb -> 12mb 제한 초과




### 3. 이진 탐색 사용 (성공)

정렬을 보장한 자료 구조를 사용하지 말고 특정 값보다 큰 수의 개수를 세는 방식으로 접근 방법을 바꿨다

먼저 입력으로 들어온 값들을 이중 벡터에 저장한다

N이 1500일 때 1500 * 1500 * 4 = 9mb로 12mb 제한에서 통과한다

첫 번째 행을 입력받을 때 가장 최솟값을 찾고, 마지막 행을 입력받을 때 가장 최댓값을 찾는다

그 후에 최솟값과 최댓값의 중간값을 사용해 그것보다 큰 수의 개수를 세어 N번째로 큰 수가 있는지를 탐색한다

- left = 최솟값
- right = 최댓값

이렇게 하면 N번째로 큰 수는 중간값(left+(right-left)/2)보다 큰 수의 개수가 정확히 N-1 일때가 되고 종료되는 시점 left >= right 에서의 left가 N번째로 큰 숫자가 된다


```C++

vector<vector<int>> board;
int n;
int countLarger(int mid) {
	int cnt = 0;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			if (board[i][j] > mid) cnt++;
		}
	}
	return cnt;
}

int main() {

	fastio;

	cin >> n;

	board.resize(n, vector<int>(n));

	int MAX = 0;
	int MIN = 1000000000;

	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			cin >> board[i][j];
			if (i == n - 1) {
				MAX = max(MAX, board[i][j]);
			}
			if (i == 0) {
				MIN = min(MIN, board[i][j]);
			}
		}
	}

	int left = MIN;
	int right = MAX;

	while (left <= right) {
		int mid = left + (right - left) / 2;
		if (countLarger(mid) >= n) {
			left = mid + 1;
		}
		else {
			right = mid - 1;
		}
	}

	cout << left;

	return 0;
}

```








